# Unit 2: Simple programs

# Lecture 4: Functions

---
---
## 2.5 Decomposition and abstraction

### How do we write code?
---

- so far...
    - covered language mechanisms
    - know how to write different files for each computation
    - each file is some piece of code
    - each code is a set of instructions
- problems with this approach
    - easy for small-scale problems
    - messy for larger problems
    - hard to keep track of details
    - how do we know the right info is supplied to the right part of code?

---
### Good programming
---

- more code not necessarily a good thing
- measure good programmers by the amount of functionality
- introduce **functions**
    - encapsulate pieces of computation
- mechanism to achieve *decomposition* (a.k.a modularity) and *abstraction*

---
### Example/analogy — projector
---

- a projector is a black box
    - don't know how it works, construct whose details we don't understand
    - we do know the interface: input/output
        - this interface is a standard interface—can connect any electronics to it that can communicate with that input for the purpose of producing an output
            - black box somehow converts image from input source to a projection on a wall, magnifying it
> - **abstraction idea**: do not need to know how a projector works to use it

- projecting large image in an event such as the Olympics opening ceremony decomposed into separate tasks for separate projectors
    - each projector takes input and produces separate output
    - all projectors work together to produce a larger image
> - **decomposition idea**: different devices work together to achieve an end goal

---
### Apply these ideas to programming
---

- **decomposition**
    - break problem into different, self-contained pieces
- **abstraction**
    - suppress details of method to compute something from use of that computation

---
### Create structure with decomposition
---

- building on same example of multiple, separate devices
- in programming, divide code into **modules**
    - are **self-contained**
    - used to **break up** code
    - intended to be **reusable**
    - keep code **organized**
    - keep code **coherent**
- goals:
    - this lecture, achieve decomposition with functions
    - in a few weeks, achieve decomposition with classes

---
### Suppress details with abstraction
---

- in example, no need to know how to build a projector
- in programming, can think of a piece of code as a black box
    - do not need to see details
    - do not want to see details
    - hide tedious coding details
- goal:
    - achieve abstraction with **function specifications** or **docstrings**

---
### Decomposition and abstraction
---

- powerful together
- code can be used many times but only has to be debugged once

---
---
## 2.6 Introducing functions

### Functions
---

- reusable pieces/chunks of code
- functions are not run in a program until they are "called" or "invoked"
- function characteristics:
    - has a **name**
    - has **parameters** (0 or more)
    - has a **docstring** (technically optional documentation that describes what the function does)
    - has a **body**, the sequence of commands/instructions to run when function is called

---
### How to write and call/invoke a function
---

```python
def is_even(i):
    """
    Input: i, a positive int
    Returns True if i is even, otherwise False
    """
    print('hi')
    return i%2 == 0

is_even(3)
```

- in this small example, we can see in the top line:
    - `def` is the keyword we use to begin **defining** the function
    - `is_even` is the **name** of the function, a string of our choosing
    - `i` is the single **parameter** for this function, and we're giving this a name (think of it like a variable name)
    - the `:` at the end finishes off the top line, where we've defined the function
- immediately below the top line, in triple double quotes, is the **docstring**
    - it's up to us how to use this, but traditionally we would use this to specify the intended inputs and outputs for the function
        - we can think of this as a bit like a *contract*
    - a nice thing about docstrings is that our editors/IDEs show them when we go to call our function, which is a nice little reminder for the conditions of the function
- below the docstring is the body of the function
    - this is the sequence of commands or expressions we want to evaluate when we're ready to use this function
    - notice the indentation, as this is telling us where the body of the function is, and where the function ultimately ends
    - the body in this particular example is simply going to print out the string `hi` and **return** a value—we'll get back to this return value in a second...

So, there's our function...how do we use it?  
Well, the function has a name, so we can use that inside an expression such as we would a variable!  

In particular, later on in the code, we can say an expression like `is_even` with parentheses that contain the parameters we'd like to pass to the function.  

So, calling this function looks like this: `is_even(3)`  
In passing that value, `3`, to the function, we're effectively going to be using it everywhere we see an `i` in the body of the function.  

In the last line of the code, we see the keyword `return`, which tells us we're ready to stop the computation; the value of the expression on that line is the **return value**—we can think of this as the final value that we're "handing back" in executing the function.  

In this case, we simply handed this value back to the shell, but we'll soon see how these return values can be used as part of another computation.  

---
---
## 2.7 Calling functions and scope

